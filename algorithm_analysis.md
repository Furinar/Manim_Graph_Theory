# 图搜索算法运行逻辑分析

本文档基于 `algorithm_video.py` 中的代码实现，详细分析了图结构及 BFS、DFS、Dijkstra、A\* 四种算法在该图上的具体运行过程。

## 1. 图结构定义

### 节点 (Nodes)

图包含 6 个节点，坐标如下（用于计算启发式距离）：

- **S**: 起点
- **A**, **B**, **C**, **D**: 中间节点
- **T**: 终点

### 边及权重 (Edges & Weights)

这是一个**无向带权连通图**。
| 边 (Edge) | 权重 (Weight) |
| :--- | :---: |
| (S, A) | 3 |
| (S, B) | 1 |
| (A, C) | 2 |
| (A, D) | 5 |
| (B, D) | 2 |
| (C, T) | 4 |
| (D, T) | 3 |
| (C, D) | 1 |

---

## 2. 算法运行逻辑详细分析

### 2.1 BFS (广度优先搜索)

**核心机制**：使用**队列 (Queue)**，先进先出 (FIFO)。
**邻居处理**：代码中对邻居进行了字母序排序 (`neighbors.sort()`)。

**执行步骤**：

1.  **初始化**：队列 `['S']`，已访问 `{'S'}`。
2.  **S 出队**：
    - 邻居：A, B。
    - **A 入队**：队列 `['A']`，标记 A 已访问。
    - **B 入队**：队列 `['A', 'B']`，标记 B 已访问。
3.  **A 出队**：
    - 邻居：S(已访问), C, D。
    - **C 入队**：队列 `['B', 'C']`，标记 C 已访问。
    - **D 入队**：队列 `['B', 'C', 'D']`，标记 D 已访问。
4.  **B 出队**：
    - 邻居：S(已访问), D(已访问)。
    - 无新节点入队。队列 `['C', 'D']`。
5.  **C 出队**：
    - 邻居：A(已访问), D(已访问), T。
    - **T 入队**：队列 `['D', 'T']`，标记 T 已访问。
6.  **D 出队**：
    - 邻居：A, B, C, T (均已访问)。
    - 无新节点入队。队列 `['T']`。
7.  **T 出队**：
    - **找到终点**，算法结束。

**最终路径**：S -> B -> D -> T (注意：BFS 在无权图中能找到最短路，但在带权图中不一定。这里 BFS 找到的路径 S->B->D->T 长度为 1+2+3=6，而 S->A->C->T 为 3+2+4=9，S->A->C->D->T 为 3+2+1+3=9。在这个特定图中，BFS 碰巧找到了较短的路径，但这取决于图的结构和邻居访问顺序)。
_修正：根据代码逻辑 `parent` 的记录，S 的邻居是 A 和 B。如果 B 先被处理（因为 S->B 权重小？不，BFS 不看权重。代码中 `neighbors.sort()`，所以 A 先入队，B 后入队）。_
_更正 BFS 路径追踪_：

- S -> A (parent[A]=S)
- S -> B (parent[B]=S)
- A -> C (parent[C]=A)
- A -> D (parent[D]=A)
- B -> D (D 已被 A 访问，parent[D] 保持为 A) -> **注意：代码中 `if neighbor not in visited`，因为 A 先出队把 D 访问了，所以 D 的父节点是 A。**
- C -> T (parent[T]=C)
- **路径回溯**：T -> C -> A -> S。
- **实际 BFS 路径**：**S -> A -> C -> T** (长度 3+2+4=9)。

---

### 2.2 DFS (深度优先搜索)

**核心机制**：使用**栈 (Stack)**，后进先出 (LIFO)。
**邻居处理**：代码中对邻居进行了逆序排序 (`neighbors.sort(reverse=True)`)，然后压栈。这意味着字母序小的邻居在栈顶，会先被访问。

**执行步骤**：

1.  **初始化**：栈 `['S']`，已访问 `{'S'}`。
2.  **S 出栈**：
    - 邻居：A, B。排序后 [B, A]。
    - B 入栈，A 入栈。栈 `['B', 'A']`。
    - 记录 parent[B]=S, parent[A]=S。
3.  **A 出栈**：
    - 邻居：C, D (S 已访问)。排序后 [D, C]。
    - D 入栈，C 入栈。栈 `['B', 'D', 'C']`。
    - 记录 parent[D]=A, parent[C]=A。
4.  **C 出栈**：
    - 邻居：D, T (A 已访问)。排序后 [T, D]。
    - D 已在 visited? 代码逻辑是 `if neighbor not in visited` 才入栈。
    - 注意：代码中 `visited` 是在入栈时标记的。
    - S 出栈时，A, B 入栈并标记 visited。
    - A 出栈时，C, D 入栈并标记 visited。
    - C 出栈时，邻居 D 已被标记 visited (在 A 的邻居处理时)，所以 D 不会再次入栈。
    - 邻居 T 未访问。T 入栈。栈 `['B', 'D', 'T']`。
    - 记录 parent[T]=C。
5.  **T 出栈**：
    - **找到终点**，算法结束。

**最终路径**：**S -> A -> C -> T**。

---

### 2.3 Dijkstra (迪杰斯特拉算法)

**核心机制**：使用**优先队列 (Priority Queue)**，贪心策略，每次选择当前距离起点最近的节点。
**公式**：`dist[v] = min(dist[v], dist[u] + weight(u, v))`

**执行步骤**：

1.  **初始化**：PQ `[(0, 'S')]`，dist `{'S': 0, others: inf}`。
2.  **S 出队** (d=0)：
    - 邻居 A: dist = 0+3=3。PQ `[(1, 'B'), (3, 'A')]`。parent[A]=S。
    - 邻居 B: dist = 0+1=1。PQ `[(1, 'B'), (3, 'A')]`。parent[B]=S。
3.  **B 出队** (d=1)：
    - 邻居 D: dist = 1+2=3。PQ `[(3, 'A'), (3, 'D')]` (顺序取决于堆实现)。parent[D]=B。
4.  **A 出队** (d=3)：
    - 邻居 C: dist = 3+2=5。PQ `[(3, 'D'), (5, 'C')]`。parent[C]=A。
    - 邻居 D: dist = 3+5=8 > 3 (现有 dist[D])，不更新。
5.  **D 出队** (d=3)：
    - 邻居 C: dist = 3+1=4 < 5 (现有 dist[C])。更新 C。PQ `[(4, 'C'), (5, 'C')]` (旧的 C 仍在堆中，但在出队时会被 visited 检查忽略)。parent[C]=D。
    - 邻居 T: dist = 3+3=6。PQ `[(4, 'C'), (5, 'C'), (6, 'T')]`。parent[T]=D。
6.  **C 出队** (d=4)：
    - 邻居 T: dist = 4+4=8 > 6，不更新。
7.  **C 出队** (d=5)：
    - 已访问，跳过。
8.  **T 出队** (d=6)：
    - **找到终点**，算法结束。

**最终路径**：

- 回溯：T (parent=D) -> D (parent=B) -> B (parent=S) -> S
- 路径：**S -> B -> D -> T** (总权重 6)。

---

### 2.4 A\* (A-Star 算法)

**核心机制**：使用**优先队列**，结合实际代价 g(n) 和启发式预估代价 h(n)。
**公式**：`f(n) = g(n) + h(n)`
**启发函数 h(n)**：欧几里得距离 \* 0.8 (代码定义)。

**执行步骤** (假设 h 值如下，需根据坐标计算)：

- S(-6,0), T(1.5,0) -> dist=7.5 -> h(S) ≈ 6.0
- A(-3.5,2.5), T(1.5,0) -> dist≈5.59 -> h(A) ≈ 4.5
- B(-3.5,-2.5), T(1.5,0) -> dist≈5.59 -> h(B) ≈ 4.5
- C(-1.0,2.5), T(1.5,0) -> dist≈3.54 -> h(C) ≈ 2.8
- D(-1.0,-2.5), T(1.5,0) -> dist≈3.54 -> h(D) ≈ 2.8
- T(1.5,0) -> h(T) = 0

1.  **初始化**：PQ `[(6.0, 'S')]`。
2.  **S 出队**：
    - 邻居 A: g=3, h=4.5, f=7.5。PQ `[(5.5, 'B'), (7.5, 'A')]`。
    - 邻居 B: g=1, h=4.5, f=5.5。PQ `[(5.5, 'B'), (7.5, 'A')]`。
3.  **B 出队** (f=5.5)：
    - 邻居 D: g=1+2=3, h=2.8, f=5.8。PQ `[(5.8, 'D'), (7.5, 'A')]`。parent[D]=B。
4.  **D 出队** (f=5.8)：
    - 邻居 C: g=3+1=4, h=2.8, f=6.8。PQ `[(6.0, 'T'), (6.8, 'C'), (7.5, 'A')]`。parent[C]=D。
    - 邻居 T: g=3+3=6, h=0, f=6.0。PQ `[(6.0, 'T'), (6.8, 'C'), (7.5, 'A')]`。parent[T]=D。
5.  **T 出队** (f=6.0)：
    - **找到终点**。

**最终路径**：

- 回溯：T (parent=D) -> D (parent=B) -> B (parent=S) -> S
- 路径：**S -> B -> D -> T**。
- **特点**：A\* 相比 Dijkstra 访问了更少的节点（A 甚至可能未出队），因为它有方向性地向 T 搜索。

## 3. 总结对比

| 算法         | 路径结果         | 路径长度 (权重和) | 节点访问特征                               |
| :----------- | :--------------- | :---------------- | :----------------------------------------- |
| **BFS**      | S -> A -> C -> T | 9                 | 盲目向四周扩散，按层级访问。               |
| **DFS**      | S -> A -> C -> T | 9                 | 一条路走到黑，受邻居顺序影响大。           |
| **Dijkstra** | S -> B -> D -> T | 6 (最优)          | 严格按距离增长顺序扩展，保证最短路。       |
| **A\***      | S -> B -> D -> T | 6 (最优)          | 利用启发函数加速，优先探索更有希望的方向。 |
