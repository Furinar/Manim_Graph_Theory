# 图搜索算法运行逻辑分析

本文档基于 `algorithm_video.py` 中的代码实现，详细分析了图结构及 BFS、DFS、Dijkstra、A\* 四种算法在该图上的具体运行过程。

## 1. 图结构定义

### 节点 (Nodes)

图包含 6 个节点，坐标如下（用于计算 A* 启发式距离）：

- **S**: 起点 `[-6.0, 0, 0]`
- **A**: `[-3.5, 2.5, 0]`
- **B**: `[-3.5, -2.5, 0]`
- **C**: `[-1.0, 2.5, 0]`
- **D**: `[-1.0, -2.5, 0]`
- **T**: 终点 `[1.5, 0, 0]`

### 边及权重 (Edges & Weights)

这是一个**无向带权连通图**。

| 边 (Edge) | 权重 (Weight) |
| :--- | :---: |
| (S, A) | 3 |
| (S, B) | 1 |
| (A, C) | 2 |
| (A, D) | 5 |
| (B, D) | 2 |
| (C, T) | 4 |
| (D, T) | 3 |
| (C, D) | 1 |

---

## 2. 算法运行逻辑详细分析

### 2.1 BFS (广度优先搜索)

**核心机制**：使用**队列 (Queue)**，先进先出 (FIFO)。
**邻居处理**：代码中对邻居进行了**升序排序** (`neighbors.sort()`)。

**执行步骤**：

1.  **初始化**：队列 `['S']`，已访问 `{'S'}`。
2.  **S 出队**：
    - 邻居：A, B。
    - **A 入队**：队列 `['A']`，标记 A 已访问。`parent[A]=S`。
    - **B 入队**：队列 `['A', 'B']`，标记 B 已访问。`parent[B]=S`。
3.  **A 出队**：
    - 邻居：S(已访问), C, D。
    - **C 入队**：队列 `['B', 'C']`，标记 C 已访问。`parent[C]=A`。
    - **D 入队**：队列 `['B', 'C', 'D']`，标记 D 已访问。`parent[D]=A`。
4.  **B 出队**：
    - 邻居：S(已访问), D(已访问)。
    - 无新节点入队。队列 `['C', 'D']`。
5.  **C 出队**：
    - 邻居：A(已访问), D(已访问), T。
    - **T 入队**：队列 `['D', 'T']`，标记 T 已访问。`parent[T]=C`。
6.  **D 出队**：
    - 邻居：A, B, C, T (均已访问)。
    - 无新节点入队。队列 `['T']`。
7.  **T 出队**：
    - **找到终点**，算法结束。

**最终路径**：**S -> A -> C -> T** (总权重 3+2+4=9)。
**总结**：BFS 在无权图中能找到最短路径（最少边数），但在带权图中不一定（如本例，实际最短路径为 6）。

---

### 2.2 DFS (深度优先搜索)

**核心机制**：使用**栈 (Stack)**，后进先出 (LIFO)。
**邻居处理**：代码中对邻居进行了**降序排序** (`neighbors.sort(reverse=True)`)，然后压栈。这意味着字母序小的邻居在栈顶，会先被访问。
**访问标记**：在**入栈时**标记 `visited`。

**执行步骤**：

1.  **初始化**：栈 `['S']`，已访问 `{'S'}`。
2.  **S 出栈**：
    - 邻居：A, B。排序后 [B, A]。
    - **B 入栈**：栈 `['B']`，标记 B 已访问。`parent[B]=S`。
    - **A 入栈**：栈 `['B', 'A']`，标记 A 已访问。`parent[A]=S`。
3.  **A 出栈** (栈顶)：
    - 邻居：C, D (S 已访问)。排序后 [D, C]。
    - **D 入栈**：栈 `['B', 'D']`，标记 D 已访问。`parent[D]=A`。
    - **C 入栈**：栈 `['B', 'D', 'C']`，标记 C 已访问。`parent[C]=A`。
4.  **C 出栈** (栈顶)：
    - 邻居：D, T (A 已访问)。排序后 [T, D]。
    - D 已在 `visited` 中 (在步骤 3 中被 A 访问过)，跳过。
    - **T 入栈**：栈 `['B', 'D', 'T']`，标记 T 已访问。`parent[T]=C`。
5.  **T 出栈** (栈顶)：
    - **找到终点**，算法结束。

**最终路径**：**S -> A -> C -> T** (总权重 9)。
**总结**：DFS 倾向于深层探索，不保证找到最短路径。

---

### 2.3 Dijkstra (迪杰斯特拉算法)

**核心机制**：使用**优先队列 (Priority Queue)**，贪心策略，每次选择当前距离起点最近的节点。
**公式**：`dist[v] = min(dist[v], dist[u] + weight(u, v))`

**执行步骤**：

1.  **初始化**：PQ `[(0, 'S')]`，dist `{'S': 0, others: inf}`。
2.  **S 出队** (d=0)：
    - 邻居 A: dist = 0+3=3。PQ `[(1, 'B'), (3, 'A')]`。`parent[A]=S`。
    - 邻居 B: dist = 0+1=1。PQ `[(1, 'B'), (3, 'A')]`。`parent[B]=S`。
3.  **B 出队** (d=1)：
    - 邻居 D: dist = 1+2=3。PQ `[(3, 'A'), (3, 'D')]` (顺序取决于堆实现)。`parent[D]=B`。
4.  **A 出队** (d=3)：
    - 邻居 C: dist = 3+2=5。PQ `[(3, 'D'), (5, 'C')]`。`parent[C]=A`。
    - 邻居 D: dist = 3+5=8 > 3 (现有 dist[D])，不更新。
5.  **D 出队** (d=3)：
    - 邻居 C: dist = 3+1=4 < 5 (现有 dist[C])。更新 C。PQ `[(4, 'C'), (5, 'C')]` (旧的 C 仍在堆中，但在出队时会被 visited 检查忽略)。`parent[C]=D`。
    - 邻居 T: dist = 3+3=6。PQ `[(4, 'C'), (5, 'C'), (6, 'T')]`。`parent[T]=D`。
6.  **C 出队** (d=4)：
    - 邻居 T: dist = 4+4=8 > 6，不更新。
7.  **C 出队** (d=5)：
    - 已访问，跳过。
8.  **T 出队** (d=6)：
    - **找到终点**，算法结束。

**最终路径**：**S -> B -> D -> T** (总权重 6)。
**总结**：Dijkstra 保证找到带权图的最短路径。

---

### 2.4 A\* (A-Star 算法)

**核心机制**：使用**优先队列**，结合实际代价 g(n) 和启发式预估代价 h(n)。
**公式**：`f(n) = g(n) + h(n)`
**启发函数 h(n)**：`round(np.linalg.norm(pos1 - pos2) * 0.8, 1)` (欧几里得距离 * 0.8)

**执行步骤** (h 值估算)：
- h(S) ≈ 6.0, h(A) ≈ 4.5, h(B) ≈ 4.5, h(C) ≈ 2.8, h(D) ≈ 2.8, h(T) = 0

1.  **初始化**：PQ `[(6.0, 'S')]`。
2.  **S 出队**：
    - 邻居 A: g=3, h=4.5, f=7.5。PQ `[(5.5, 'B'), (7.5, 'A')]`。
    - 邻居 B: g=1, h=4.5, f=5.5。PQ `[(5.5, 'B'), (7.5, 'A')]`。
3.  **B 出队** (f=5.5)：
    - 邻居 D: g=1+2=3, h=2.8, f=5.8。PQ `[(5.8, 'D'), (7.5, 'A')]`。`parent[D]=B`。
4.  **D 出队** (f=5.8)：
    - 邻居 C: g=3+1=4, h=2.8, f=6.8。PQ `[(6.0, 'T'), (6.8, 'C'), (7.5, 'A')]`。`parent[C]=D`。
    - 邻居 T: g=3+3=6, h=0, f=6.0。PQ `[(6.0, 'T'), (6.8, 'C'), (7.5, 'A')]`。`parent[T]=D`。
5.  **T 出队** (f=6.0)：
    - **找到终点**。

**最终路径**：**S -> B -> D -> T** (总权重 6)。
**总结**：A* 利用启发信息优先探索更有希望的方向，效率通常高于 Dijkstra。

---

## 3. 算法特性总结 (视频展示内容)

| 算法 | 策略 | 数据结构 | 适用场景 | 优缺点摘要 |
| :--- | :--- | :--- | :--- | :--- |
| **BFS** | 层层推进 | Queue | 无权图最短路 | **优点**: 无权图最短路, 简单<br>**缺点**: 无法处理带权图, 内存大 |
| **DFS** | 深度优先 | Stack | 连通性/遍历 | **优点**: 内存小, 深层目标快<br>**缺点**: 不能最快找到最短路径(耗时长), 可能死循环 |
| **Dijkstra** | 贪心(最短) | Priority Queue | 带权图最短路 | **优点**: 保证最短路, 适用广<br>**缺点**: 无法处理负权边, 效率低于启发式 |
| **A\*** | 启发式(预估) | Priority Queue | 高效路径规划 | **优点**: 效率高, 保证最短路(h可采纳)<br>**缺点**: 内存大, 启发函数难设计 |
